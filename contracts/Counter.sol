// SPDX-License-Identifier: MIT
pragma solidity ^0.7.0;

// KeeperCompatible.sol imports the functions from both ./KeeperBase.sol and
// ./interfaces/KeeperCompatibleInterface.sol
import "@chainlink/contracts/src/v0.7/KeeperCompatible.sol";

contract Counter is KeeperCompatibleInterface {
    /**
    * Public counter variable
    */
    address public owner;
    uint public counter;
    bool public running = true;
    /**
    * Use an interval in seconds and a timestamp to slow execution of Upkeep
    */
    uint public immutable interval;
    uint public lastTimeStamp;

    event IncrementedCounter(uint);

    constructor(uint updateInterval) {
        owner = msg.sender;
        interval = updateInterval;
        lastTimeStamp = block.timestamp;
        counter = 0;
    }
    /*
    [def] checkData: Data passed to the contract when checking for Upkeep. 
    Specified in the Upkeep registration so it is always the same for 
    a registered Upkeep.

    [def] upkeepNeeded: Indicates whether the Keeper should call performUpkeep 
    or not.

    [def] performData: Bytes that the Keeper should call performUpkeep with, if Upkeep 
    is needed. If you would like to encode data to decode later, try abi.encode.

    In most cases your checkUpkeep method should be marked as view. 
    This might not always be possible if you want to use more advanced 
    Solidity features like DelegateCall. It is a best practice to import 
    the KeeperBase.sol interface and use the cannotExecute modifier to 
    ensure that the method can be used only for simulation purposes.
    */


    // Keeper node calls checkUpkeep to determine if there is work to be done (implicit bool return)
    function checkUpkeep(bytes calldata /* checkData */) external override returns (bool upkeepNeeded, bytes memory /* performData */) {
        require(running == true, "Running = false");
        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    /*
    When your checkUpkeep returns upkeepNeeded == true, the Keeper 
    node broadcasts a transaction to the blockchain to execute your 
    contract code with performData as an input.

    The Upkeep that is performed is subject to the callGasLimit 
    in the configuration of the registry.

    Ensure your performUpkeep is idempotent. Your performUpkeep 
    should change state such that checkUpkeep will not return true 
    for the same subset of work once said work is complete. Otherwise 
    the Upkeep will remain eligible and result in multiple performances 
    by the Keeper Network on the exactly same subset of work.
    */

    // performs the work on the contract, if instructed by checkUpkeep().
    function performUpkeep(bytes calldata /* performData */) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        require(running == true, "Running = false");
        if ((block.timestamp - lastTimeStamp) > interval ) {
            lastTimeStamp = block.timestamp;
            counter = counter + 1;
            emit IncrementedCounter(counter);
        }
        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }

    function toggleOnOff(bool _onOff) external {
        require(msg.sender == owner, "Owner only");
        running = _onOff;
    }
}